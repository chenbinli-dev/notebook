以下内容转载自**[brickspert](https://github.com/brickspert)**(砖家)的blog仓库：  https://github.com/brickspert/blog/issues/34 ，以便个人学习使用。

React Hooks 是 react v16.8 的一个新特性，很佩服这么重磅的功能，在一个小版本中发布，说明 React 团队有足够的信心向上兼容。

## Why Hooks？

[![image-20200116191817331](https://camo.githubusercontent.com/128d0f2b7d16e133c1ee60cc4772ca083c1cc8f054d5246e9df94270e6bccebc/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353039373237382d31626365346533312d323139312d343735612d393861302d3437326531346161363733652e706e67)](https://camo.githubusercontent.com/128d0f2b7d16e133c1ee60cc4772ca083c1cc8f054d5246e9df94270e6bccebc/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353039373237382d31626365346533312d323139312d343735612d393861302d3437326531346161363733652e706e67)

为什么要放弃 Class，转用 Hooks 呢？在内部外部有很多争论，包括知乎也有类似提问。我们也不免俗套的要对比下 Class 和 Hooks 了。当然为了保证今天的分享效果，我肯定会偏向 Hooks 的（哈哈哈哈）。

[![image-20200116192324872](https://camo.githubusercontent.com/cd4a4e842b52d7dbfa7d0388c0c4211a81054fbe3b417e6811239922458ed8e5/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353130353935312d32316534626337352d383166362d343236302d396663372d6131343633316638613034322e706e67)](https://camo.githubusercontent.com/cd4a4e842b52d7dbfa7d0388c0c4211a81054fbe3b417e6811239922458ed8e5/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353130353935312d32316534626337352d383166362d343236302d396663372d6131343633316638613034322e706e67)

### Class 学习成本高

Class 学习成本很高。首当其中的就是生命周期，多，太多了。不仅多，还会变！React v15 和 v16 就不一样。下面是我在网上随便找的一张图。

[![image-a5b927b35025](https://camo.githubusercontent.com/6b2dfe5076955c11c71bb30d3e88f73ff8be81ed78f63a1ed055d9fb8588aa9e/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353131353737352d35353131333137612d376466322d343736642d616563622d6135623932376233353032352e706e67)](https://camo.githubusercontent.com/6b2dfe5076955c11c71bb30d3e88f73ff8be81ed78f63a1ed055d9fb8588aa9e/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353131353737352d35353131333137612d376466322d343736642d616563622d6135623932376233353032352e706e67)

这个是 React v15 的生命周期，你都掌握了吗？你知道 v16 有什么变化吗？

之前无论你去哪里面试，基本都会有几个必问问题：

- 讲讲 React 生命周期？React v15 和 React v16 生命周期有啥变化？
- 如何优化 Class 组件？shouldComponentUpdate 是做什么的？如何用？
- 一般在哪个生命周期发送网络请求？为什么？
- ......

生命周期最重要，但是有很高的学习成本，需要大量实践才能积累足够的经验。当然，这几个问题回答不好，百分之八十以上的几率会挂掉。

当然不止是生命周期，this 也是一个很大的问题。你有没有在组件写很多 `bind`？或者所有的函数都用箭头函数定义？

```
this.someFunction = this.someFunction.bind(this);

// 或
someFunction = ()=>{}
```

为什么要这样写呢？如果不写会有什么问题？哎呦，又多了一个面试题，你会吗？

### Hooks 学习成本低

对比 Class，Hooks 的学习成本可就太低了！掌握了 useState 和 useEffect，80% 的事情就搞定了。

[![image-7cbf7879e7cf](https://camo.githubusercontent.com/2a3e16a8738c66ed6f503d6747daebceea688eb7596530f8798c2237428fc4d5/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353134393636322d30653663303635632d313838342d343938642d396662622d3763626637383739653763662e706e67)](https://camo.githubusercontent.com/2a3e16a8738c66ed6f503d6747daebceea688eb7596530f8798c2237428fc4d5/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353134393636322d30653663303635632d313838342d343938642d396662622d3763626637383739653763662e706e67)

### Class 业务逻辑分散

Class 业务逻辑分散，实现一个功能，我要写在不同的生命周期里面，不聚合~

比如，如果你有个定时器，你一定要在 `componentWillUnMount` 去卸载。

[![image-67b7d915f6af](https://camo.githubusercontent.com/94bf994afeb27747d25e75a1e7b9a44ba6336b35ab1f6d7b68a433588d81bba8/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353135383336322d63636561646638322d323364372d346330382d623038392d3637623764393135663661662e706e67)](https://camo.githubusercontent.com/94bf994afeb27747d25e75a1e7b9a44ba6336b35ab1f6d7b68a433588d81bba8/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353135383336322d63636561646638322d323364372d346330382d623038392d3637623764393135663661662e706e67)

再比如，我们要写一个请求用户信息的组件，当`userId` 变化时，要重新发起请求。我们就要在两个生命中期中写请求的逻辑。

[![image-4059e72aa129](https://camo.githubusercontent.com/0183e235e10d64a4ea95af7a78e3bee140782cb457117c903f8feff93edc4818/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353136383237382d33646461653165392d353265342d346666322d393030312d3430353965373261613132392e706e67)](https://camo.githubusercontent.com/0183e235e10d64a4ea95af7a78e3bee140782cb457117c903f8feff93edc4818/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353136383237382d33646461653165392d353265342d346666322d393030312d3430353965373261613132392e706e67)

相信上面的逻辑，大家也是经常会写的吧。

奥奥，sorry，上面的 `componentWillReceiveProps` 已经被废弃了，我们应该用 `componentDidUpdate` 来代替。

“咦，这是为啥呢？好好的为什么要废弃，不让这么用了？”

又来一个面试题！你知道答案吗？

### Hooks 业务逻辑聚合

而 Hooks 的业务逻辑就非常聚合了。上面的两个例子，改成 Hooks 你会写吗？

[![image-3780dc60b735](https://camo.githubusercontent.com/d22e0797d0e48507c3d7dcd2ec0c39160d418f1a95d0b078a5ae960d911ff214/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353137363231322d66376234623934372d363433382d346633372d386333642d3337383064633630623733352e706e67)](https://camo.githubusercontent.com/d22e0797d0e48507c3d7dcd2ec0c39160d418f1a95d0b078a5ae960d911ff214/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353137363231322d66376234623934372d363433382d346633372d386333642d3337383064633630623733352e706e67)

[![image-88e9ba8a7add](https://camo.githubusercontent.com/c6cd28c8736cb79d0eb851dd5ae88ba2f37c00a9342465644f7e958830142f43/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353138323638372d61353465376535392d343637332d343437612d626139392d3838653962613861376164642e706e67)](https://camo.githubusercontent.com/c6cd28c8736cb79d0eb851dd5ae88ba2f37c00a9342465644f7e958830142f43/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353138323638372d61353465376535392d343637332d343437612d626139392d3838653962613861376164642e706e67)

简直不要太简单！香啊！我可以提前下班了。

### Class 逻辑复用困难

说到逻辑复用，很多同学会说 Class 的 Render Props 和 HOC（高阶组件）可以做逻辑复用！那我们看看 Class 的逻辑复用有多么的惨不忍睹。

首先我们看看 Render Props。

首先我们想复用监听 window size 变化的逻辑，开开心心的写了下面的代码。

[![image-f9273eefa2ef](https://camo.githubusercontent.com/f44f77e46ab016e7059a75a7590bfb61f6ad3aaf239b621ca40af0e6ca8a75b3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353138393536302d34396366623536382d613135332d346138642d613766302d6639323733656566613265662e706e67)](https://camo.githubusercontent.com/f44f77e46ab016e7059a75a7590bfb61f6ad3aaf239b621ca40af0e6ca8a75b3/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353138393536302d34396366623536382d613135332d346138642d613766302d6639323733656566613265662e706e67)

然后，我又想复用监听鼠标位置的逻辑，我只能这么写了。

[![image-d60b6492b570](https://camo.githubusercontent.com/7293f25c5a2ffff893a8fb12b82f87f703183d86094a95e7e0a27af07b8228f5/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353139373236332d30396463326263662d613261632d343538302d386137622d6436306236343932623537302e706e67)](https://camo.githubusercontent.com/7293f25c5a2ffff893a8fb12b82f87f703183d86094a95e7e0a27af07b8228f5/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353139373236332d30396463326263662d613261632d343538302d386137622d6436306236343932623537302e706e67)

到这里你应该看到了问题所在。这简直就是地狱！我不忍心复用其它逻辑了。

我们放过 Render Props，来看看 HOC 吧。

> 如果你要问什么是 HOC，那我不得不推荐我的另外一篇文章《[助你完全理解React高阶组件（Higher-Order Components）](https://github.com/brickspert/blog/issues/2)》。
>
> 哪怕你不知道 HOC 是啥，你也一定用过。比如 redux 的 connect。

[![image-20200116200932301](https://camo.githubusercontent.com/f3641260913ff00b98e988c35af958fd1d207639a169b58e677afa5dae3df230/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353230363730372d32363262363536372d613231392d346532332d386634612d3530636565336431316234662e706e67)](https://camo.githubusercontent.com/f3641260913ff00b98e988c35af958fd1d207639a169b58e677afa5dae3df230/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353230363730372d32363262363536372d613231392d346532332d386634612d3530636565336431316234662e706e67)

上面的代码，我用了三个 HOC，分别是 redux 的 connect，react-intl 的 injectIntl，以及 AntD 的 Form.create()。

这是一个非常常见的用法。如果你光看代码，大概已经懵圈了。“我是谁？我在哪？我要干什么？”

这会我仿佛听见 HOC 在说：“我不仅让你看不懂我，我还很容易出各种问题。”

是的，HOC 很容易出问题。大家都往组件的 props 上面挂属性，万一有个重名的，那就只能说一句“不好意思，GG思密达”！

### Hooks 逻辑复用简单

Hooks 来了，它表示，我要一个打五个！Render Props 和 HOC 联合起来也被我秒杀！

[![image-5a6f5d648ca9](https://camo.githubusercontent.com/c0a81cb976e3f5bee720a54dc61961eab4523688a8fd67a175a9d2f221e59e9f/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353231353332352d35363230633338622d666262312d346330362d623064632d3561366635643634386361392e706e67)](https://camo.githubusercontent.com/c0a81cb976e3f5bee720a54dc61961eab4523688a8fd67a175a9d2f221e59e9f/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353231353332352d35363230633338622d666262312d346330362d623064632d3561366635643634386361392e706e67)

Hooks 表示，来十个，来一百个我也能打。

Hooks 最强的能力就是逻辑复用了，这是我最最最爱的能力了。

### Hooks 会产生很多闭包问题

是的，我也不偏袒 Hooks，由于 React Hooks 的机制，如果用法不正确，会导致各种奇怪的闭包问题。

> 如果你要问 React Hooks 的机制是什么的话，我又要给你推荐一篇我之前写的文章了：《[React Hooks 原理](https://github.com/brickspert/blog/issues/26)》。

那面对这个问题，怎么解呢？说实话，我也没有很好的解决办法。

但是，这可能也有好处。如果碰到想不明白的问题，那 99% 是由于闭包导致的，我们有很确定的方向去排查问题。

[![image-4636b47be14f](https://camo.githubusercontent.com/cbe1ddc61b8b126ad57ce0bf978dfa00b92fd6648b17b74187a39e78706b4c8a/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353232333130372d64643439333531612d333634622d343332642d393735612d3436333662343762653134662e706e67)](https://camo.githubusercontent.com/cbe1ddc61b8b126ad57ce0bf978dfa00b92fd6648b17b74187a39e78706b4c8a/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353232333130372d64643439333531612d333634622d343332642d393735612d3436333662343762653134662e706e67)

记住这句话，你可以少走很多弯路。

## Show Case

[![image-20200116203233594](https://camo.githubusercontent.com/cdedec2fea57ed197533ea95effe170d3a682cb8f6e815f8f91cce50870ba0b7/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353233313733332d30316333666236662d633732612d346136662d613261392d3630333430613765313937312e706e67)](https://camo.githubusercontent.com/cdedec2fea57ed197533ea95effe170d3a682cb8f6e815f8f91cce50870ba0b7/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353233313733332d30316333666236662d633732612d346136662d613261392d3630333430613765313937312e706e67)

当然，说再多，吹再好，也没多大用。我上面讲的 Class 和 Hooks 的优缺点，网上的也有很多人讲，大家也肯定都看过。

用程序员的交流方式，就是“Talk is cheap，Show me the code.”。

亮剑吧！

接下来，我会用一个例子，让你折服，拜倒在 Hooks 的石榴裙下。如果你不服，咱们单独撕~

### 网络请求组件实现

[![image-20200116214124140](https://camo.githubusercontent.com/fcfc75679bb59a3abd1b071dea31d18cdf049e4041a58dd2cf0949284bcb1f4c/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353234303037312d37356636313032382d313663392d346265302d393832322d6438653435393235626165302e706e67)](https://camo.githubusercontent.com/fcfc75679bb59a3abd1b071dea31d18cdf049e4041a58dd2cf0949284bcb1f4c/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353234303037312d37356636313032382d313663392d346265302d393832322d6438653435393235626165302e706e67)

接下来，我们来实现一个最最最常见的组件。该组件接收 userId，然后发起网络请求，获得用户信息。

说白了，就是最简单的发起网络请求的组件。我们先用 Class 来实现看看。

[![image-20200116214639300](https://camo.githubusercontent.com/7365006d3f5dd73120e71036bf4c1a7fe2680f4b2592dc7e756e47ffe91eb2bf/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353234373639312d66353365623035652d636639662d343963332d393064332d6264373535363238373633322e706e67)](https://camo.githubusercontent.com/7365006d3f5dd73120e71036bf4c1a7fe2680f4b2592dc7e756e47ffe91eb2bf/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353234373639312d66353365623035652d636639662d343963332d393064332d6264373535363238373633322e706e67)

这段代码，是最简单的网络请求。

- 定义一个 username 状态。
- componentDidMount 的时候发起网络请求。
- 网络请求结束，更新 username。

美滋滋。但是少了点东西。网络请求，我们肯定要维护一个 loading 状态，保证用户体验比较好。

那我们加上吧。

[![image-20200116214918755](https://camo.githubusercontent.com/e832aeb778c9d8f7f316b08ef60c4b20bddb41654dc2ac984f99d0a4f119049d/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353235373236342d31616162333137322d386365642d343263622d383866612d6662323463626635336236392e706e67)](https://camo.githubusercontent.com/e832aeb778c9d8f7f316b08ef60c4b20bddb41654dc2ac984f99d0a4f119049d/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353235373236342d31616162333137322d386365642d343263622d383866612d6662323463626635336236392e706e67)

这张图，我们增加了 loading 状态，在网络请求发起前，置为 true，在网络请求结束后，置为 false。

美滋滋。但是还是少点东西。userId 变化后，我要重新发起网络请求吧。

我们再加点代码吧。

[![image-20200116215101730](https://camo.githubusercontent.com/1116c78d446e64e5bf7a0a6ee79d36dfc3ec7de59fc0d525e15ae5658f21a68f/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353236343832312d30386335653530302d306461612d346131632d623864302d3733613466346436653932392e706e67)](https://camo.githubusercontent.com/1116c78d446e64e5bf7a0a6ee79d36dfc3ec7de59fc0d525e15ae5658f21a68f/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353236343832312d30386335653530302d306461612d346131632d623864302d3733613466346436653932392e706e67)

我们增加了对 userId 变化的监听，如果 userId 变化后，重新发起请求。

这次稳了吧？

不不不，还不够。如果 userId 连续变化了 5 次，发送了 5 个网络请求，我们要保证总是最后一次网络请求有效。也就是经常说的的“竞态处理”或者“时序控制”。

我加！加还不行吗！

[![image-20200116215409524](https://camo.githubusercontent.com/d9d5ebdaf633d9eed2f1945cce7ffe4968c7600ef1dc28531f8d404e167dff60/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353237333432302d64383535353939392d656365312d343765332d386562662d3263643936353763346266362e706e67)](https://camo.githubusercontent.com/d9d5ebdaf633d9eed2f1945cce7ffe4968c7600ef1dc28531f8d404e167dff60/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353237333432302d64383535353939392d656365312d343765332d386562662d3263643936353763346266362e706e67)

其实到这里，有些同学已经懵了。“你说的时序控制，听着很有道理，但我平时都没处理过这个问题，我看下你怎么实现的。”

确实，时序控制不算一个简单的问题，很多新手都不会解决这个问题。

稳了！到这里你觉得稳了吧。

还是年轻啊，小伙子。

[![image-20200116220003295](https://camo.githubusercontent.com/08381ae550d5b93000b1a438eceb0e2731a4f2b13d838883e8ea2478c184e11a/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353238383239362d30653539383333312d626165662d346135622d613963322d3339343737383165313031612e706e67)](https://camo.githubusercontent.com/08381ae550d5b93000b1a438eceb0e2731a4f2b13d838883e8ea2478c184e11a/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353238383239362d30653539383333312d626165662d346135622d613963322d3339343737383165313031612e706e67)

如果用上面的代码来玩，你可能会偶尔碰到上面的警告。这个警告是怎么造成的呢？我说一下你就明白了。下面四个步骤执行，必会报警告：

1. 组件加载
2. 发起网络请求
3. 组件卸载
4. 网络请求请求成功，触发 setState

看出问题了吗？组件已经卸载了，还去 setState，造成了内存溢出。

怎么解决呢？

[![image-20200116220311200](https://camo.githubusercontent.com/81107864b76ef3924e039cbfb5af0d0afa5c9919a81fc61e3c20514cacb2e1cb/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353239353835352d39333739353437302d343536312d346137632d613134662d6533313562303638313336622e706e67)](https://camo.githubusercontent.com/81107864b76ef3924e039cbfb5af0d0afa5c9919a81fc61e3c20514cacb2e1cb/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353239353835352d39333739353437302d343536312d346137632d613134662d6533313562303638313336622e706e67)

在组件卸载的时候，放弃最后一次请求。

到这里为止，我们就完成了一个完美的网络请求。这次真结束了！

看下写了多少行代码。

[![image-20200116220531399](https://camo.githubusercontent.com/f82684153deb53c4eaabf6616b2722068230009760fada41838e8be446bf60f9/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353330333038362d62303033353766332d616631392d343031332d383964612d3866313832346266666466352e706e67)](https://camo.githubusercontent.com/f82684153deb53c4eaabf6616b2722068230009760fada41838e8be446bf60f9/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353330333038362d62303033353766332d616631392d343031332d383964612d3866313832346266666466352e706e67)

除去空格，我们写了 38 行代码。实话说，38 行代码我能忍，但是这些逻辑我忍不了！回想下我们处理了多少逻辑：

- 网络请求
- loading
- userId 变化重新发起请求
- 竞态处理
- 组件卸载放弃网络请求

关键这些逻辑是没办法复用的！每个项目可能有数十上百个组件会发网络请求，我就要写几十，几百遍这样的逻辑。想想我都难受。

> 说实话，我在写项目的时候经常会偷懒。要不就不写 loading，要不就不管竞态，要不就不管最后的内存溢出警告。
>
> 你有没有和我一样呢？嘿嘿。

言归正传，接下来就邀请 Hooks 登场了。

[![image-20200116221123031](https://camo.githubusercontent.com/8a1a9a9f92f5cc78b4f2958bcfaa9c07fe47c1ff88a94f702d194a72743ca74e/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353331313931312d61643036613737312d336535332d343662392d393066382d6631383464356234646166612e706e67)](https://camo.githubusercontent.com/8a1a9a9f92f5cc78b4f2958bcfaa9c07fe47c1ff88a94f702d194a72743ca74e/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353331313931312d61643036613737312d336535332d343662392d393066382d6631383464356234646166612e706e67)

三下五除二，我们用 Hooks 实现了刚才所有的逻辑。

[![image-20200116221212124](https://camo.githubusercontent.com/30130f5330be84bc506436b9494d42502316333068772f61ad3e805d04526870/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353331393031302d61343132326134342d656530342d343363612d613134612d3665326235373630383630302e706e67)](https://camo.githubusercontent.com/30130f5330be84bc506436b9494d42502316333068772f61ad3e805d04526870/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353331393031302d61343132326134342d656530342d343363612d613134612d3665326235373630383630302e706e67)

17 行！代码量减少了 50% 以上。好像还行！

但是，别忘了，Hooks 最重要的能力就是逻辑复用！这些逻辑我们完全可以封装起来！我们把刚才的逻辑全部封装起来！

[![image-20200116221359407](https://camo.githubusercontent.com/a61a521ec0eb9186d63920e8e5764ecb47981caddb4a36646d3ab3b86468661e/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353332363134352d65653666653161622d333036622d343133372d616335302d6531393232393062363033322e706e67)](https://camo.githubusercontent.com/a61a521ec0eb9186d63920e8e5764ecb47981caddb4a36646d3ab3b86468661e/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353332363134352d65653666653161622d333036622d343133372d616335302d6531393232393062363033322e706e67)

useAsync 封装了刚才我们说的所有功能，一行代码完成了网络请求。

最后整个组件会长这样。

[![image-20200116221605411](https://camo.githubusercontent.com/5b9a4a5c53e480030d7e07bf7dfb2667e33cb47539f20038389561b6cb55fe70/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353333333836362d38613766633333382d633337332d343761312d613536342d3562656136383138663832612e706e67)](https://camo.githubusercontent.com/5b9a4a5c53e480030d7e07bf7dfb2667e33cb47539f20038389561b6cb55fe70/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353333333836362d38613766633333382d633337332d343761312d613536342d3562656136383138663832612e706e67)

哇！我自己都佩服自己！简直了！美呆了，帅毙了，感觉自己无敌了！提前完成工作，下班回家！

[![image-20200116221755193](https://camo.githubusercontent.com/ab88e2abb330f85defa084017b9cd0b7022bc87452c10bbd1a7e2bc1e8525337/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353334313936362d38333264613063652d663336332d346533612d393032342d3433666161613833356364362e706e67)](https://camo.githubusercontent.com/ab88e2abb330f85defa084017b9cd0b7022bc87452c10bbd1a7e2bc1e8525337/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353334313936362d38333264613063652d663336332d346533612d393032342d3433666161613833356364362e706e67)

通过这个例子，我想证明一个论点：“**使用 Hooks 封装逻辑的能力，可以极大提高开发效率**”。

## Umi Hooks

这时候你肯定要问，useAsync 在哪里？给我瞧瞧？

[![image-20200116221941442](https://camo.githubusercontent.com/f704dbc5d285421b6fbe8e0ecf1a41c53feee7f686315bebd7a0601190299351/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353335313233392d66353264326561612d323630342d343231652d393364382d6530646232376465653139342e706e67)](https://camo.githubusercontent.com/f704dbc5d285421b6fbe8e0ecf1a41c53feee7f686315bebd7a0601190299351/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353335313233392d66353264326561612d323630342d343231652d393364382d6530646232376465653139342e706e67)

### useAsync

useAsync 在[这里](https://hooks.umijs.org/useAsync)，快来瞧，快来看啦！

useAsync 是 [Umi Hooks](https://github.com/umijs/hooks) 库的核心 Hooks 之一，Umi Hooks 提供了大量提炼自业务的 Hooks。一行代码真的可以实现很多功能！

> Umi Hooks [在这里](https://github.com/umijs/hooks)！[在这里](https://github.com/umijs/hooks)！你懂的~~

[![image-20200116222352082](https://camo.githubusercontent.com/01c511f758ec2bb99ae9f1b8d561c051714e14d2397874e1e7c4d1381b742f8c/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353336383938382d34393935393936622d383266372d343862632d626331332d3363373562353531666665612e706e67)](https://camo.githubusercontent.com/01c511f758ec2bb99ae9f1b8d561c051714e14d2397874e1e7c4d1381b742f8c/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353336383938382d34393935393936622d383266372d343862632d626331332d3363373562353531666665612e706e67)

当然，useAsync 不止包含上面说的功能，还支持“手动触发”执行，还支持“轮询”！

只要简单的配置一个 `pollingInterval` ，就能轮询发送请求了。[快去试试啦](https://hooks.umijs.org/useAsync#polling)！

接下来我们会介绍几个更牛的 Hooks 给大家认识！

### useAntdTable

[![image-cc2f4b087aca](https://camo.githubusercontent.com/490675afac634b828b0cd1aaf286d13d716d03db2d3ea0218dd5b0034e88d5a0/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f6769662f3138393335302f313537393233333238343931362d37373665633133312d383865652d346235342d393630662d6363326634623038376163612e676966)](https://camo.githubusercontent.com/490675afac634b828b0cd1aaf286d13d716d03db2d3ea0218dd5b0034e88d5a0/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f6769662f3138393335302f313537393233333238343931362d37373665633133312d383865652d346235342d393630662d6363326634623038376163612e676966)

AntD 的 Table 组件，想必大家在项目中经常用到吧！除了刚才异步请求的所有逻辑外，你还得处理其它的逻辑。

[![image-20200116232857059](https://camo.githubusercontent.com/dc55097a82dc19263e8f823bf0b08cc781ab440a87a9a53abccce895f7533698/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353435313239382d37356465373332382d656334632d343661362d623433362d6562613665653837636663632e706e67)](https://camo.githubusercontent.com/dc55097a82dc19263e8f823bf0b08cc781ab440a87a9a53abccce895f7533698/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353435313239382d37356465373332382d656334632d343661362d623433362d6562613665653837636663632e706e67)

比如维护 page、pageSize、sorter、filter 的状态，还得考虑搜索条件变化后，重置 page 到第一页。这些逻辑光想想就头疼了，别说写了。

现在一行代码就可以实现了！[useAntdTable](https://hooks.umijs.org/useAntdTable)，封装了所有的逻辑，只要一行代码！如图上所示，你只要 `...tableProps`，就可以了。这也许就是幸福的味道吧~

### useLoadMore

加载更多的场景，比如下面动图的场景，想必大家在工作中都写过。

[![image-22fa47992b6f](https://camo.githubusercontent.com/364a757b7407f0a721d53230c1a4bd74b9686bcdd6a912da90c4da6468a5c311/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f6769662f3138393335302f313537393233333333333031322d38366130326232372d656236362d346361612d396434302d3232666134373939326236662e676966)](https://camo.githubusercontent.com/364a757b7407f0a721d53230c1a4bd74b9686bcdd6a912da90c4da6468a5c311/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f6769662f3138393335302f313537393233333333333031322d38366130326232372d656236362d346361612d396434302d3232666134373939326236662e676966)

这样一个加载更多的场景，我们要维护多少状态？写多少行逻辑？本来我打算写个 Class 实现的例子贴出来的，但是我放弃了，因为太难了~~

随便想想要处理的逻辑：

- 第一次加载时候的 loading
- 加载更多时候的 loading
- 维护 page 和 pageSize
- 网络请求
- 是不是加载全了
- 搜索条件变化后，重置到第一页。
- .....

脑壳疼，真的脑壳疼。我会写，但是写起来真的好累。

还没完，一般产品同学还会要求，上拉加载更多......

[![image-cf629db68ebc](https://camo.githubusercontent.com/607ab1cb7ca271d97450c9a09a82be951e30129b78a7b35ceadfd69c31d44ac6/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f6769662f3138393335302f313537393233333334383732372d66393533336238332d333363642d346165392d616536332d6366363239646236386562632e676966)](https://camo.githubusercontent.com/607ab1cb7ca271d97450c9a09a82be951e30129b78a7b35ceadfd69c31d44ac6/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f6769662f3138393335302f313537393233333334383732372d66393533336238332d333363642d346165392d616536332d6366363239646236386562632e676966)

这时候我们还得监听滚动位置，如果快到底了，触发加载更多。脑壳更疼了！

[![image-20200116235013101](https://camo.githubusercontent.com/76b3e3e35bfa6adbb4eed44859f7deae95b88c53cbb76a2d973677201bdc01e1/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353436383633392d30616333623261622d366665332d343534322d396663392d3536333137666161663030362e706e67)](https://camo.githubusercontent.com/76b3e3e35bfa6adbb4eed44859f7deae95b88c53cbb76a2d973677201bdc01e1/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353436383633392d30616333623261622d366665332d343534322d396663392d3536333137666161663030362e706e67)

Umi Hooks 听到了你的求救，派出 [useLoadMore](https://hooks.umijs.org/useLoadMore) 来拯救你了。一行代码就可以实现所有的功能！一个小时变一分钟，又可以早点下班了。

### useDynamicList

[![image-20200116235455431](https://camo.githubusercontent.com/00cb97fb2c0102f1d1fbc0cf7110d42032b1540f52225288125fa6129facabbe/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353437373032392d63333863326434342d633562652d346334352d623638372d6664613735366161383065332e706e67)](https://camo.githubusercontent.com/00cb97fb2c0102f1d1fbc0cf7110d42032b1540f52225288125fa6129facabbe/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353437373032392d63333863326434342d633562652d346334352d623638372d6664613735366161383065332e706e67)

还有更好用的，比如 [useDynamicList](https://hooks.umijs.org/useDynamicList)，下面的动态列表，一行代码搞定。

[![image-16556dfcf0e8](https://camo.githubusercontent.com/7de83fc38175d23e3558562aa220e1f004f55fb2740380a6908a49efa8c7db69/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f6769662f3138393335302f313537393233333338343436382d38373536663162612d346138342d343136612d396435652d3136353536646663663065382e676966)](https://camo.githubusercontent.com/7de83fc38175d23e3558562aa220e1f004f55fb2740380a6908a49efa8c7db69/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f6769662f3138393335302f313537393233333338343436382d38373536663162612d346138342d343136612d396435652d3136353536646663663065382e676966)

### useBoolean

不仅是上面讲到的各种复杂逻辑可以封装。简单的逻辑封装起来也是极其好用的，比如 Boolean 值的管理。

我们一般控制 Modal，Popover 等显示隐藏的时候，都要维护一个 visible 状态。大概会是这样。

[![image-20200116235651552](https://camo.githubusercontent.com/1dd1231c60fb7032442785a9bf122c21d5a52acef8abd0ecd38b66f60b5fd9f8/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353439303837382d61633232303839612d663665652d343237382d383735622d6634383733386132326364612e706e67)](https://camo.githubusercontent.com/1dd1231c60fb7032442785a9bf122c21d5a52acef8abd0ecd38b66f60b5fd9f8/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353439303837382d61633232303839612d663665652d343237382d383735622d6634383733386132326364612e706e67)

这样的逻辑，你写过多少遍？没有几千也有几百吧！

[![image-20200116235850057](https://camo.githubusercontent.com/d7c68812f254b4b6348aee0817cb6b1fd906d0552122b34556d37d063ceecf41/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353439373036342d35333932343234352d353834312d343365372d626238352d3931303932613163666462322e706e67)](https://camo.githubusercontent.com/d7c68812f254b4b6348aee0817cb6b1fd906d0552122b34556d37d063ceecf41/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353439373036342d35333932343234352d353834312d343365372d626238352d3931303932613163666462322e706e67)

以后你就可以用 [useBoolean](https://hooks.umijs.org/useBoolean) 咯！

### More

[![image-20200116235957789](https://camo.githubusercontent.com/7724e5fa575b67b1284c25303823db7c465fca651df41a9a7e748783119b7cd4/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353530343136372d31613637396162302d396365382d346239392d386631332d3765666137623939653230612e706e67)](https://camo.githubusercontent.com/7724e5fa575b67b1284c25303823db7c465fca651df41a9a7e748783119b7cd4/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353530343136372d31613637396162302d396365382d346239392d386631332d3765666137623939653230612e706e67)

不仅是上面讲到的这些，我们还有很多很多的 Hooks。

比如 [useSearch](https://hooks.umijs.org/useSearch)，就封装了通常异步搜索场景的逻辑，比如 debounce。

比如 [useVirtualList](https://hooks.umijs.org/useVirtualList)，就封装了虚拟列表的逻辑。

[![image-20200117000249183](https://camo.githubusercontent.com/0b500cb0031d0e92a4d3495ee1441a28757f601d3a5817ed68f70c5427def05d/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353531343837322d39383265323338382d626235662d343966322d613030392d6262623134613861613234302e706e67)](https://camo.githubusercontent.com/0b500cb0031d0e92a4d3495ee1441a28757f601d3a5817ed68f70c5427def05d/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353531343837322d39383265323338382d626235662d343966322d613030392d6262623134613861613234302e706e67)

比如 [useMouse](https://hooks.umijs.org/zh-cn/useMouse)，封装了监听鼠标位置的逻辑。

比如 [useKeyPress](https://hooks.umijs.org/zh-cn/useKeyPress)，封装了监听键盘按键的逻辑。

[![image-20200117000412951](https://camo.githubusercontent.com/8d52f615a264584f7814783c012bdbdbd3f36b9f42d753dc1179e8520e933967/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353532383136312d61393861353764312d353637352d343463342d396433362d6665336563656165663933352e706e67)](https://camo.githubusercontent.com/8d52f615a264584f7814783c012bdbdbd3f36b9f42d753dc1179e8520e933967/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353532383136312d61393861353764312d353637352d343463342d396433362d6665336563656165663933352e706e67)

30+ Hooks 供您选择，并且我们仍然处于婴儿期，快速发展中。我们的愿景就是：**封装别人的逻辑，让别人无逻辑可写。**

## 未来规划

[![image-20200117001130397](https://camo.githubusercontent.com/6eb887ebbe5692ce9fb6aff2a4de71b50ebbf426689d837920d0e5d35a58c29d/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353533333938372d63373166653132322d323766612d346231662d383637642d6562396533356264336333612e706e67)](https://camo.githubusercontent.com/6eb887ebbe5692ce9fb6aff2a4de71b50ebbf426689d837920d0e5d35a58c29d/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353533333938372d63373166653132322d323766612d346231662d383637642d6562396533356264336333612e706e67)

### 更多的 Hooks 开发

如上面所述，我们现在还处于婴儿期，需要不断汲取能量，更多的 Hooks 正在路上！要实现“**让别人无逻辑可写**”的目标，还需继续奋斗。

### 更强大的 useRequest

[![image-20200117001209280](https://camo.githubusercontent.com/5be335ce49e44c06244466bfca809fb43037eb7fb11c829bdc1c7681257eaf84/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353534323033372d36353138663836652d666636312d343765642d616131382d6136373766386139303833372e706e67)](https://camo.githubusercontent.com/5be335ce49e44c06244466bfca809fb43037eb7fb11c829bdc1c7681257eaf84/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313537393233353534323033372d36353138663836652d666636312d343765642d616131382d6136373766386139303833372e706e67)

大家应该都听过 [useSWR](https://link.zhihu.com/?target=https%3A//github.com/zeit/swr/) 吧？是 zeit 公司开发的一个专门做网络请求的 Hooks，提供了很多新颖的思路，给了我们非常大的启发，github star 就像坐火箭一样。但在实际项目使用中，还是会有很多地方不符合蚂蚁内部的体系。但是它给我们非常大的启发，基于 swr 的思路，我们可以实现更强大的 useRequest！图上的能力，我们都要！

useRequest 目前已经处于内测期了，下个版本将会与大家见面！我们的目标是：所有的网络请求，只用 useRequest 就够了！

### Hooks 生态

目前社区上 Hooks 相关的基础教程、进阶教程、原理深入、常见问题等文档都比较分散，我们准备向 Hooks 生态发展，提供各式各样的文章。以后学习 Hooks，使用 Hooks，找 Umi Hooks 就对了。

当然，生态方面目前正在规划中，预计年后启动。